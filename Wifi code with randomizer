# --- Imports
import time
import board
import busio
import pwmio
import neopixel
import adafruit_vl53l0x
from digitalio import DigitalInOut, Direction
from analogio import AnalogOut, AnalogIn
from adafruit_esp32spi import adafruit_esp32spi
from adafruit_esp32spi import adafruit_esp32spi_wifimanager
import adafruit_esp32spi.adafruit_esp32spi_socket as socket
import adafruit_minimqtt as MQTT
from adafruit_led_animation.animation.blink import Blink
from adafruit_led_animation.animation.comet import Comet
from adafruit_led_animation.animation.chase import Chase
from adafruit_led_animation.sequence import AnimationSequence
from adafruit_led_animation.color import PURPLE, AMBER, JADE

try:
    from settings import settings
except ImportError:
    print("Settings import failed")
    raise

board_id = 1
client_id = "1"

vorige_state = False

er_is_ergens_iemand = False
aanwezigheids_lijst = [False, False, False, False, False, False]

## Create a input time of flight on pin I2C
i2c = busio.I2C(board.SCL, board.SDA)
sensor1 = adafruit_vl53l0x.VL53L0X(i2c)

pixel_pin = board.A2
pixel_num = 30

pixels = neopixel.NeoPixel(pixel_pin, pixel_num, brightness=0.2, auto_write=False)
chase = Chase(pixels, speed=0.01 , size=3, spacing=30, color=AMBER)

OUT = (0, 0, 0)

# --- Wifi Variables
esp32_cs = DigitalInOut(board.D9)
esp32_ready = DigitalInOut(board.D11)
esp32_reset = DigitalInOut(board.D12)
spi = busio.SPI(board.SCK, board.MOSI, board.MISO)
esp = adafruit_esp32spi.ESP_SPIcontrol(spi, esp32_cs, esp32_ready, esp32_reset)
wifi = adafruit_esp32spi_wifimanager.ESPSPI_WiFiManager(esp, settings)
ip = str(settings['ip'])

# --- MQTT Variables
mqtt_client = MQTT.MQTT(broker=ip, port=1883, client_id=client_id)

old_a0_val = 0
first = True

Trigger1 = 500

def no_proximity():
    global Trigger1, sensor1
    if sensor1.range > Trigger1:
        return True
    else:
        return False

def person_there():
    global Trigger1, Trigger2, sensor1
    if sensor1.range < Trigger1:
        return True
    else:
        return False

def setup():
    wifi_mqtt_setup()

def mqtt_loop():
    while True:
        try:
            mqtt_client.loop()
            er_is_ergens_iemand = False
            for aanwezigheid in aanwezigheids_lijst:
                if aanwezigheid:
                    er_is_ergens_iemand = True

            if er_is_ergens_iemand:
                pixels.fill(OUT)
                pixels.show()
            else:
                chase.animate(0.1)

            break
        except (ValueError, RuntimeError) as e:
            print("Failed to get data, retrying\n", e)
            wifi.reset()
            mqtt_client.reconnect()


# --- Upon receiving a message from the broker, the client will extract the command and payload.
def message(client_id, t, message):
    global command, payload, message_received
    if t.split("/")[2] != str(board_id):
        if message == "Iemand is er!":
            if random () > 0.5:
                aanwezigheids_lijst[int(t.split("/")[2])] = True
        if message == "Niemand daar!":
            aanwezigheids_lijst[int(t.split("/")[2])] = False

# --- loop: code to run every time in the main loop

def loop():
    try:
        mqtt_client.loop()
        pixels.fill(AMBER)
        pixels.show()
        # time determines the send frequency
 #         break
    except (ValueError, RuntimeError) as e:
        print("Failed to get data, retrying\n", e)
        wifi.reset()
        mqtt_client.reconnect()


# --- WiFi & MQTT setup
def wifi_mqtt_setup():
    print("Connecting to WiFi...")
    wifi.connect()
    print("Connected!")
    MQTT.set_socket(socket, esp)
    mqtt_client.on_connect = connected
    mqtt_client.on_disconnect = disconnected
    mqtt_client.on_message = message
    print("Connecting to MQTT broker...")
    mqtt_client.connect()


# --- When connected to the MQTT broker, the client subscribes to a topic.
def connected(client, userdata, flags, rc):
    print(
        "Connected to MQTT broker! Listening for actuator instructions on %s"
        % board_id
    )
    for i in range(1,5):
        client.subscribe("/paal/" + str(i))


# --- This function executes when the client disconnects from the broker
def disconnected(client, userdata, rc):
    print("Disconnected from MQTT Broker!")


# --- Main program
setup()

while True:
    if no_proximity():
        aanwezigheids_lijst[client_id] = False
        mqtt_loop()
        if vorige_state:
            values_string = "Niemand daar!"
            mqtt_client.publish("/paal/" + str(board_id), values_string)
        vorige_state = False
    if person_there():
        aanwezigheids_lijst[client_id] = True
        loop()
        if not vorige_state:
            values_string = "Iemand is er!"
            mqtt_client.publish("/paal/" + str(board_id), values_string)
        vorige_state = True
